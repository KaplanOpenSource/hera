#! /usr/bin/env python
import argparse
import json
import os

from hera import toolkitHome
from hera.simulations.hermesWorkflowToolkit import actionModes,simulationTypes,HERAMETADATA
from hera.utils import loggedObject,loadJSON
from hera.simulations.openFoam.utils import buildCaseExecutionScript
from hermes import workflow
from hermes.utils.workflowAssembly import handler_build,handler_buildExecute,handler_expand,handler_execute


def add(args):
    """
        Adds a new simulation to the group. The workflow is expanded and store in the db under the requested group.

        If the groupName is None, extract the group name from the simulation name. that is,
        assume that the simulation name is <group name>_<id>.

    Parameters
    ----------
    args:
        workflow : The workflow file that will be prepared.
        groupName : The group of the simulation.
        variations : Json with the parameter variations on the requested workflow.
                    The structure of the JSON is:
                    {
                        "parameterVariation" : {
                                TBD
                        }
                    }
        simulationType: the type of the simulation.

        overwrite : bool,
                overwite thw workflow with the given name
        force:   bool,
            add the simulation to the db, even if the workflow exists under a different name.
        assignName: bool,
            generate automated name to the workflow
        action   : Add, AddBuild, or AddBuildExecute
                Add - just adds the simulation to the db
                AddBuild - add the simulation to the db, and then write the workfow and python execution code.
                AddBuildExecute - add the simulation to the db, write the workflow and the python execution code,
                              the run the execution code

    Returns
    -------
        None
    """
    logger = loggedObject("bin.hera_workflows.add").logger
    logger.info(" -- Starting: adding workflow to the group --")


    conf = loadJSON(args.workflow)
    projectName = conf[HERAMETADATA]['projectName'] if args.projectName is None else args.projectName

    wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)

    simulationGroup         = conf[HERAMETADATA]['simulationGroup'] if args.simulationGroup is None else args.simulationGroup

    if args.variations is None:
        logger.info("No variations supplied. Adding one simulation. ")
        workflowFile = args.workflow
        logger.info(f"Adding workflow in {workflowFile} to group {simulationGroup}.")

        action = getattr(actionModes, args.action.upper())

        try:
            wftk.addToGroup(workflowJSON=workflowFile,
                            groupName=simulationGroup,
                            assignName=args.assignName,
                            overwrite=args.overwrite,
                            action=action,
                            force=args.force)

            buildExecScriptsFromCaseName(workflowFile)
        except FileExistsError as e:
            print(e)

    else:
        # should load the combinations....
        raise NotImplementedError("Loading the combinations... Not implemented yet... ")

def create(arguments):
    """
            Create a JSON from the name of the simulation (or from a JSON file) and assignes a new empty name to it.
            It does NOT build or adds it to the DB. to do so, use the add subcommand

    Parameters
    ----------
    arguments
        workflow : The workflow file that will be prepared.
        groupName : The group of the simulation.
        variations : Json with the parameter variations on the requested workflow.
                    The structure of the JSON is:
                    {
                        "parameterVariation" : {
                                TBD
                        }
                    }
        simulationType: the type of the simulation.

        overwrite : bool,
                overwite thw workflow with the given name


    Returns
    -------

    """
    logger = loggedObject("bin.hera_workflows.add").logger
    logger.info(" -- Starting: adding workflow to the group --")

    conf = loadJSON(arguments.workflow)
    projectName = conf[HERAMETADATA]['projectName'] if arguments.projectName is None else arguments.projectName

    wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)

    simulationGroup         = conf[HERAMETADATA]['simulationGroup'] if arguments.simulationGroup is None else arguments.simulationGroup
    workflowType            = simulationTypes.WORKFLOW.value


    if arguments.variations is None:
        logger.info("No variations supplied. Creating one simulation. ")
        groupID, simulationName = wftk.findAvailableName(simulationGroup=simulationGroup, simulationType=workflowType)
        logger.info(f"Creating workflow in {simulationName} (group ID {groupID}) to group {simulationGroup}. Using workflow type: {workflowType}.")

        if not os.path.exists(simulationName) or arguments.overwrite:
            with open(f"{simulationName}.json","w") as newfile:
                json.dump(conf,newfile,indent=4)
        else:
            raise FileExistsError(f"The workflow {simulationName} exists in that directory. Use --overwrite to overwrite it.")

    else:
        # should load the combinations....
        raise NotImplementedError("Loading the combinations... Not implemented yet... ")


def deleteSimulations(arguments):
    """
        deletes the simulation/list of simulations from the DB.
        The default is to export them to the disk (unless no-export flag is supplied
    Parameters
    ----------
    arguments:
        projectName: if not supplied get from the deleted object.

    Returns
    -------

    """
    logger = loggedObject("bin.hera_workflows.delete").logger
    logger.info(f" -- Starting: Deleting simulations --")

    if os.path.isfile(arguments.object):

        heraMetadata = loadJSON(arguments.object).get(HERAMETADATA, None)
        if heraMetadata is None:
            raise ValueError(f"No hera metadata in {arguments.workflow}. Supply metadata or a project name. ")
        projectName = heraMetadata['projectName']
        simulationGroup = heraMetadata['simulationGroup']
        simuationType = heraMetadata['workflowType']

        wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)

    else:
        if arguments.projectName is None:
            raise ValueError(f"Must supply a projectName. use --projectName ")
        projectName = arguments.projectName
        wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)

    docList =wftk.getSimulationDocumentFromDB(arguments.object)

    if len(docList) == 0:
        print("No simulations found!")
    else:
        for x in docList:
            print(f"Deleting {x.desc['simulationName']} in Group {x.desc['groupName']}")
            x.delete()


def listSimulations(arguments):
    """
            Lists the simulations in the group.
    Parameters
    ----------
    arguments
        projectName : the name of the project
        groupName   : the group
        type : the document type to query [optional]


    Returns
    -------
        A list of all the simulations in the group.
    """
    logger = loggedObject("bin.hera_workflows.list").logger
    logger.info(f" -- Starting: Listing simulations --")

    simulationGroup = None

    if os.path.isfile(arguments.object):
        heraMetadata = loadJSON(arguments.object).get(HERAMETADATA, None)
        if heraMetadata is None:
            raise ValueError(f"No hera metadata in {arguments.workflow}. Supply metadata or a project name. ")
        projectName = heraMetadata['projectName']
        simulationGroup = heraMetadata['simulationGroup']
        simuationType = heraMetadata['workflowType']

        wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)
        searchAsGroupOrName = False

    else:
        if arguments.projectName is None:
            raise ValueError(f"Must supply a projectName. use --projectName ")
        projectName = arguments.projectName
        wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)

        simDocument = wftk.getSimulationDocumentFromDB(arguments.object)
        if simDocument is not None:
            simulationGroup = simDocument[0].desc[wftk.DESC_GROUPNAME]
            simuationType = simDocument[0].type
        else:
            simDocument = wftk.getSimulationsInGroup(arguments.object)
            if len(simDocument) == 0:
                print(f"{arguments.object} is not a simulation, directory, workflow file or a simulation group in project {projectName} ")
            simulationGroup = simDocument[0].desc[wftk.DESC_GROUPNAME]
            simuationType   = simDocument[0].type

    parametersOfNodes    = arguments.parametersOfNodes
    allParams     = arguments.allParameters
    jsonFormat    = arguments.json

    simulationList = wftk.listSimulations(simulationGroup=simulationGroup,
                                          parametersOfNodes=parametersOfNodes,
                                          allParams=allParams,
                                          jsonFormat=jsonFormat)

    title = f"The simulations in group *{simulationGroup}* of the type *{simuationType}* in project *{projectName}* "

    print(title)
    print("-" * len(title))
    print(simulationList.to_string())


def listWokflowNodes(arguments):
    """
        Lists the nodes in the requested workflow. The workflow can be a file on the disk or a name
        of a simulation in the database.

    Parameters
    ----------
    arguments
            projectName: str
                The name of the project.
            workflowName: str
                A file on the disk or a simulation in the DB.
    Returns
    -------
        prints a list of all the nodes of the workflow.
    """
    logger = loggedObject("bin.hera_workflows.listNodes").logger
    logger.info(f" -- Starting: Listing workflow nodes --")

    if os.path.exists(arguments.workflowName) and not os.path.isdir(arguments.workflowName):
            json = loadJSON(arguments.workflowName)
            hermesObject = workflow(json)
    else:
        if arguments.projectName is None:
            raise ValueError("Must supply a project name for a non-file workflow")

        wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=arguments.projectName)

        hermesObject = wftk.getHermesWorkflowFromDB(arguments.workflowName)

    tlte = f"The nodes of the {arguments.workflowName}"
    print(tlte)
    print("-"*len(tlte))

    if arguments.parameters:
        for hnodeName,hnodeData in hermesObject.items():
            print(f"\t * {hnodeName}")
            for prop in hnodeData.parameters.keys():
                print(f"\t\t + {prop}")
    else:
        print("\t * "+"\n\t * ".join(hermesObject.nodeList))

def listWokflowNodeParameters(arguments):
    """
            List the parameters of the node.

    Parameters
    ----------
    arguments
            projectName: str
                The name of the project.
            nodename : str
                The name of the node to list.

            workflowName: str
                A file on the disk or a simulation in the DB.

    Returns
    -------

    """
    logger = loggedObject("bin.hera_workflows.listNodeParameters").logger
    logger.info(f" -- Starting: Listing node parameters --")

    if os.path.exists(arguments.workflowName) and not os.path.isdir(arguments.workflowName):
            json = loadJSON(arguments.workflowName)
            hermesObject = workflow(json)
    else:
        if arguments.projectName is None:
            raise ValueError("Must supply a project name for a non-file workflow")

        wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=arguments.projectName)

        hermesObject = wftk.getHermesWorkflowFromDB(arguments.workflowName)

    if arguments.filterType not in hermesObject.nodeList:
        raise ValueError(f" Node {arguments.filterType} not found in workflow {arguments.workflowName}. Existing nodes are: {','.join(hermesObject.nodeList)}")

    tlte = f"The parameters of the node {arguments.filterType} in the workflow {arguments.workflowName}"
    print(tlte)
    print("-"*len(tlte))
    print("\t - " +"\n\t - ".join(hermesObject[arguments.filterType].parameters.keys()))


def compareSimulations(arguments):
    """
            Compares two or more simulations.


    Parameters
    ----------
    arguments
        projectName : str, the name of the projet

        simulations: [groupName] - compare all the simulations,
                     [sim1,sim2,..] compare the different simulations. simX is either a simulation name in the DB or a file on the disk

        change     : show only the changes between the different parameters.
        nodes      : show only the parameters associated with a specific set of nodes.
        type       : query only simulations of a specific type.

    Returns
    -------

    """
    pass


def expandWorkflow(arguments):
    parser_expandWorkflow(arguments)

def buildExecuter(arguments):
    handler_build(arguments)
    buildExecScriptsFromCaseName(arguments.caseName)

def executeWorkflow(arguments):
    handler_execute(arguments)
    buildExecScriptsFromCaseName(arguments.caseName)

def buildAndExecute(arguments):
    handler_buildExecute(arguments)
    buildExecScriptsFromCaseName(arguments.workflow)



def buildExecScriptsFromCaseName(caseName):

    if os.path.isdir(caseName):
        configuration = os.path.basename(caseName) + ".json"
    elif os.path.isfile(caseName):
        configuration = caseName
        caseName = configuration.split(".")[0]
    else:
        raise ValueError(f"{caseName} must be directory of workflow file")

    buildCaseExecutionScript(caseDirectory=caseName, workflow=configuration)


if __name__ == "__main__":
    tk = toolkitHome.getToolkit(toolkitName=toolkitHome.LOGGING, projectName=None)
    tk.addLogger(loggerName="simulations", handlers=['console'], level='DEBUG', propagate=False)
    tk.addLogger(loggerName="simulations.hermesWorkflowToolkit", handlers=['console'], level='INFO', propagate=False)
    tk.addLogger(loggerName="bin", handlers=['console'], level='DEBUG', propagate=False)

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(help='sub-command help')

    parser_prepare = subparsers.add_parser('add', help='Adds simulations to the group.')
    parser_prepare.add_argument('workflow', type=str, help='The workflow file to load')
    parser_prepare.add_argument('--projectName', type=str, default=None, help='The project to load the data')
    parser_prepare.add_argument('--simulationGroup',dest="simulationGroup", default=None, type=str, help='The simulation group to associate the ')
    parser_prepare.add_argument('--variations', default=None, type=str, help='A file with all the variations.')
    parser_prepare.add_argument('--simulationType', dest="workflowType", default=None, type=str, help='The type of simulation ')
    parser_prepare.add_argument('--overwrite', dest="overwrite", action="store_true", default=False,
                                help='overwrite the existing workflow, if file already exists')
    parser_prepare.add_argument('--assignName', dest="assignName", action="store_true", default=False,
                                help='If true, finds a new name to the simulation based on the maximal id in the simulation group.')
    parser_prepare.add_argument('--force', dest="force", action="store_true", default=False,
                                help='Add to the db even if the workflow exists there (under a different name)')
    parser_prepare.add_argument('--action', dest="action", choices=['Add', 'AddBuild', 'AddBuildExecute','add', 'addBuild', 'addBuildExecute'],
                                help='The action: just add, just add and build, or add,build and run',
                                default='AddBuildExecute')
    parser_prepare.set_defaults(func=add)

    ### ------------------------
    parser_create = subparsers.add_parser('create', help='Creates a one or more new simulation and assignes their name from the ID of the database. Does not build or add to the DB')
    parser_create.add_argument('workflow', type=str, help='The workflow file to load')
    parser_create.add_argument('--projectName', type=str, default=None, help='The project to load the data')
    parser_create.add_argument('--simulationGroup',dest="simulationGroup", default=None, type=str, help='The simulation group to associate the ')
    parser_create.add_argument('--variations', default=None, type=str, help='A file with all the variations.')
    parser_create.add_argument('--simulationType', dest="workflowType", default=None, type=str, help='The type of simulation ')
    parser_create.add_argument('--overwrite', dest="overwrite", action="store_true", default=False,
                                help='overwrite the existing workflow, if file already exists')
    parser_create.set_defaults(func=create)

    ### ------------------------
    listSimulations_parser = subparsers.add_parser('list', help='Lists the simulations in the simulation group of that project.')
    listSimulations_parser.add_argument('object', type=str, help='A workflow file, a case directory, a name of simulation, or a group name ')
    listSimulations_parser.add_argument('--projectName', dest="projectName", default=None, type=str, help='The project name')
    listSimulations_parser.add_argument('--parameters',nargs="*", dest="parametersOfNodes", default=None, help='List the paramaters. If  nodes are given, then only list theirs.')
    listSimulations_parser.add_argument('--all', dest="allParameters",action="store_true", default=False, help='If exsists, return all the parameters of requested nodes. Else, return only the differences between the different simulations of the requested nodes.')
    listSimulations_parser.add_argument('--JSON', dest="json", default=False, type=bool,
                                        help='If exsists, return the results as JSON and not as pandas table')
    listSimulations_parser.set_defaults(func=listSimulations)

    ### ------------------------
    export = subparsers.add_parser('export', help='Saves the workflow to the disk.')
    # --build - also builds the python executer


    ### ------------------------
    compare_parser = subparsers.add_parser('compare', help='Compare two or more simulations. ')
    compare_parser.add_argument('projectName', type=str, help='The project name')
    compare_parser.add_argument('simulations', nargs="+", type=str,
                                help='[groupName] - compare all the simulations, [sim1,sim2,..] compare the different simulations. simX is either a simulation name in the DB or a file on the disk')
    compare_parser.add_argument('--JSON', dest="JSON", action="store_true", default=False,
                                help='Return the results in JSON format')
    compare_parser.add_argument('--all', default=False, action="store_true", help='Return all the parameters fields')
    compare_parser.add_argument('--nodes', nargs="+", default=None, type=str, help='The list of nodes to present')
    compare_parser.add_argument('--type', dest="docType", default=None, type=str, help='The type of simulation ')
    compare_parser.set_defaults(func=compareSimulations)

    ### ------------------------
    delete_parser = subparsers.add_parser('delete', help='Delete the run. exports the simulation that was deleted ')
    delete_parser.add_argument('object', type=str,help='A workflow file, a case directory, a name of simulation, or a group name ')
    delete_parser.add_argument('--projectName', type=str, default=None, help='The project to load the data')
    delete_parser.add_argument('--no-export', default=False, action="store_true", help='Does not save the deleted workflow to the disk')
    delete_parser.set_defaults(func=deleteSimulations)
    # --includeRun - also deletes the run.
    # --group     - deletes all the simulation with that prefix.
    # --no-export  - does not save the deleted workflow to the disk.

    ### ------------------------
    nodes = subparsers.add_parser('nodes', help='Information about the nodes in the workflow')
    noded_subparsers = nodes.add_subparsers(help='sub-command help')

    ##             +++++++++++++++++++
    nodes_list = noded_subparsers.add_parser('list', help='Lists the nodes in the workflow.')
    nodes_list.add_argument('workflowName', type=str, help='The workflow name. Can be a file on the disk or a name of simulation')
    nodes_list.add_argument('--projectName',dest="projectName",default=None, type=str, help='The project name')
    nodes_list.add_argument('--parameters', dest="parameters", action="store_true", default=False,help='Also pring the paramters of each node')
    nodes_list.set_defaults(func=listWokflowNodes)

    ###             +++++++++++++++++++
    nodes_list = noded_subparsers.add_parser('nodeParameters', help='Lists the parameters of the nodes.')
    nodes_list.add_argument('workflowName', type=str, help='The workflow name. Can be a file on the disk or a name of simulation')
    nodes_list.add_argument('nodeName', type=str, help='The node to list the paramters')
    nodes_list.add_argument('--projectName',dest="projectName",default=None, type=str, help='The project name')
    nodes_list.set_defaults(func=listWokflowNodeParameters)


    ##### execuion of the workflows.

    parser_expandWorkflow = subparsers.add_parser('expand',
                                                  help='Expands the workflow JSON with the default values of the nodes')
    parser_expandWorkflow.add_argument('workflow', type=str, help="base workflow")
    parser_expandWorkflow.add_argument('caseName', type=str, help="the name of the case to run")
    parser_expandWorkflow.set_defaults(func=expandWorkflow)

    parser_buildExecuter = subparsers.add_parser('build',
                                                 help='Builds the python execution file for the execution engine ')
    parser_buildExecuter.add_argument('workflow', type=str, help="base workflow")
    parser_buildExecuter.add_argument('caseName', type=str, help="the name of the case to run")
    parser_buildExecuter.add_argument('--parameters', type=str, default=None, required=False,
                                      help="A path to paremeters file (optional)")
    parser_buildExecuter.set_defaults(func=buildExecuter)

    parser_execute = subparsers.add_parser('execute',
                                           help='Runs the python execution file with the appropriate execution engine')
    parser_execute.add_argument('caseName', type=str, help="the name of the case to run")
    parser_execute.add_argument('--force', dest="force", default=False, action="store_true",
                                help="If exist, delete the execution files first")
    parser_execute.set_defaults(func=executeWorkflow)

    parser_runWorkflow = subparsers.add_parser('buildExecute', help='Expands, builds and executes the workflow JSON')
    parser_runWorkflow.add_argument('workflow', type=str, help="base workflow")
    parser_runWorkflow.add_argument('--force', dest="force", default=False, action="store_true",
                                    help="If exist, delete the execution files first")
    parser_execute.set_defaults(func=buildAndExecute)

    parsed = parser.parse_args()
    parsed.func(parsed)
