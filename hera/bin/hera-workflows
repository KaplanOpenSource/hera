#! /usr/bin/env python
import argparse
import json
import logging
import os
import shutil

from hera import toolkitHome
from hera.simulations.hermesWorkflowToolkit import actionModes
from hera.utils import loadJSON
from hera.utils.logging.helpers import initialize_logging, with_logger
from hermes import workflow
from hermes.utils.workflowAssembly import handler_build,handler_buildExecute,handler_expand,handler_execute

def simulationGroup_list(args):
    """
        List all the simulations group
    Parameters
    ----------
    args
        projectName : the project name. If not supplied, get from caseConfiguration

    Returns
    -------

    """
    logger = logging.getLogger("hera.bin.hera_workflows.add")
    logger.info(" -- Starting: adding workflow to the group --")

    projectName = args.projectName

    if projectName is None:
        logger.info(f"Project name is not found. Trying to load from caseConfiguration ")
        cse = loadJSON("caseConfiguration.json")
        projectName = cse.get('projectName')
        if projectName is None:
            raise ValueError(f"Project name not supplied. Provide projectName using --projectName, or in the caseConfiguration.json, projectName key ")
    else:
        logger.info(f"Using project name {projectName}. ")


    simulationType = args.type
    simulationName = args.simulationName

    wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)
    wftk.listSimulationGroups(workflowType=simulationType,simulationName=simulationName)


def workflow_add(args):
    """
        Adds a new simulation to the group. The workflow is expanded and store in the db under the requested group.

        If the groupName is None, extract the group name from the simulation name. that is,
        assume that the simulation name is <group name>_<id>.

    Parameters
    ----------
    args:
        workflow : The workflow file that will be prepared.
        groupName : The group of the simulation.
        variations : Json with the parameter variations on the requested workflow.
                    The structure of the JSON is:
                    {
                        "parameterVariation" : {
                                TBD
                        }
                    }
        simulationType: the type of the simulation.

        overwrite : bool,
                overwite thw workflow with the given name
        force:   bool,
            add the simulation to the db, even if the workflow exists under a different name.
        assignName: bool,
            generate automated name to the workflow
        action   : Add, AddBuild, or AddBuildExecute
                Add - just adds the simulation to the db
                AddBuild - add the simulation to the db, and then write the workfow and python execution code.
                AddBuildExecute - add the simulation to the db, write the workflow and the python execution code,
                              the run the execution code

    Returns
    -------
        None
    """
    logger = logging.getLogger("hera.bin.hera_workflows.add")
    logger.info(" -- Starting: adding workflow to the group --")

    projectName = args.projectName

    if projectName is None:
        logger.info(f"Project name is not found. Trying to load from caseConfiguration ")
        cse = loadJSON("caseConfiguration.json")
        projectName = cse.get('projectName')
        if projectName is None:
            raise ValueError(f"Project name not supplied. Provide projectName using --projectName, or in the caseConfiguration.json, projectName key ")
    else:
        logger.info(f"Using project name {projectName}. ")

    wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)

    workflowFile = args.workflow
    logger.info(f"Adding workflow in {workflowFile}  to DB")

    action = getattr(actionModes, args.action.upper())

    try:
        wftk.addToGroup(workflowJSON=workflowFile,
                        groupName= args.simulationGroup,
                        assignName=args.assignName,
                        overwrite=args.overwrite,
                        action=action,
                        force=args.force)

    except FileExistsError as e:
        print(e)


def workflow_delete(arguments):
    """
        deletes the simulation/list of simulations.old from the DB.
        The default is to export them to the disk (unless no-export flag is supplied
    Parameters
    ----------
    arguments:
        projectName: if not supplied get from the deleted object.

    Returns
    -------

    """
    logger = logging.getLogger("hera.bin.hera_workflows.delete")
    logger.info(f" -- Starting: Deleting workflows --")


    if arguments.projectName is None:
        logger.execution(f"projectName is not provided. Looking for the project name in the caseConfiguration.json file (projectName key) ")
        caseConfiguration = loadJSON("caseConfiguration.json")
        projectName = caseConfiguration['projectName']

    wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)

    simulationList = wftk.getSimulationDocumentFromDB(list(arguments.workflows))

    completeRemove = []

    for sim in simulationList:
        logger.info(f" Deleting the workflow: {sim['desc']['simulationName']}")
        outfileName = f"{sim['desc']['simulationName']}.json"

        if not arguments.noExport:
            logger.execution(f"Exporting the deleted document as {outfileName}")
            if not os.path.isfile(outfileName) or arguments.forceOverwrite:
                with open(outfileName,"w") as outfile:
                    json.dump(sim['desc']['workflow'],outfile,indent=4)
            else:
                logger.execution("...Document exists in dir, not exporting")

        res = sim.resource

        completeRemove.append(f"shutil.rmtree('{res}')")

        logger.debug("... remove from DB")
        sim.delete()

    with open("completeDelete.py","w") as outfile:
        outfile.write("\n".join(completeRemove))

    print("In order to remove all directories from disk type: python completeRemove.py")

    # if os.path.isfile(arguments.object):
    #
    #     heraMetadata = loadJSON(arguments.object).get(HERAMETADATA, None)
    #     if heraMetadata is None:
    #         raise ValueError(f"No hera metadata in {arguments.workflow}. Supply metadata or a project name. ")
    #     projectName = heraMetadata['projectName']
    #     simulationGroup = heraMetadata['simulationGroup']
    #     simuationType = heraMetadata['workflowType']
    #
    #     wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)
    #
    # else:
    #     if arguments.projectName is None:
    #         raise ValueError(f"Must supply a projectName. use --projectName ")
    #     projectName = arguments.projectName
    #     wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)
    #
    # docList =wftk.getSimulationDocumentFromDB(arguments.object)
    #
    # if len(docList) == 0:
    #     print("No simulations.old found!")
    # else:
    #     for x in docList:
    #         print(f"Deleting {x.desc['simulationName']} in Group {x.desc['groupName']}")
    #         x.delete()


def workflow_list(arguments):
    """
            Lists the simulations of the project.

            Parameters
            ----------
            arguments : argument struct with the field:

                - object : str, optional
                            List only the group name if exists.
.
                - projectName: str, optional
                            If not supplied, use the project name in caseConfiguration.json.

                - simulationGroup: str, optional
                            If not supplied, use the file name.

                - no-nodes    : bool [default : true].
                            If exists, does not list the node names.
                            if --parameters exists, then this option is ignored.

                - parameters [node list]: list of string, optional
                            If flag exists lists only the parameters that are different between different simulations.
                            unless --all exists. In that case, list all nodes.

                            if [node list] is not empty, lists all the parameters of this node.

                - all : boolean, [optional]
                        If --parameters flag is used, lists all the parameters if exists. Otherwise
                        list only the nodes that were changed.

            Returns
            -------
                    A string.

                    * without --parameters flag:

                    <work-flow type>
                    ----------------
                            + <group name>
                                    - simulation name : [node list]
                                    .
                                    .


                    * with --parameters exists:

                    <work-flow type> - <group name>
                     |   simulation name |  <parameters>   |
                     +-------------------+-----------------+
    """
    logger = logging.getLogger("hera.bin.hera_workflows.list")
    logger.info(f" -- Starting: Listing simulations --")

    if arguments.projectName is None:
        logger.execution(f"projectName is not provided. Looking for the project name in the caseConfiguration.json file (projectName key) ")
        caseConfiguration = loadJSON("caseConfiguration.json")
        projectName = caseConfiguration['projectName']

    wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)

    # if arguments.object is None:
    #     # Listing all the groups in the toolkit.
    #     docList =  wftk.getSimulationsDocuments(type=wftk.WORKFLOW)
    #     if docList is None:
    #         logger.info(f"There are no hermes workflows in project {projectName}")
    #
    #     groupNameList = set([x['desc']['groupName'] for x in docList])
    #
    #     title = f"The simulation groups in project *{projectName}* "
    #     print(title)
    #     print("-" * len(title))
    #     print("\n".join([x for x in groupNameList]))
    #
    # else:

    simDocument = wftk.getSimulationDocumentFromDB(arguments.object)
    if simDocument is not None:
        simulationGroup = simDocument.desc[wftk.DESC_GROUPNAME]
    else:
        simDocument = wftk.getSimulationsInGroup(arguments.object)
        if len(simDocument) == 0:
            print(f"{arguments.object} is not a simulation, directory, workflow file or a simulation group in project {projectName} ")
        simulationGroup = simDocument[0].desc[wftk.DESC_GROUPNAME]

    listNodes     = arguments.nodes
    parameters    = arguments.parameters

    simulationList = wftk.workflow_list(simulationGroup=simulationGroup,
                                        listNodes=listNodes,
                                        listParameters=parameters)


    title = f"The simulations in group *{simulationGroup}*  in project *{projectName}* "
    print(title)
    print("-" * len(title))

    for doc in simulationList:
        print(f"\t* {doc['simulationName']}")
        if listNodes:
                for node in doc['nodes']:
                    print(f"\t\t + {node}")

        if parameters:
            for nodeName,nodeData in doc['parameters'].items():

                print(f"\t\t + {nodeName}")
                for pname,pvalue in nodeData.items():
                    print(f"\t\t\t  - {pname}")


def workflowNodes_list(arguments):
    """
        Lists the nodes in the requested workflow. The workflow can be a file on the disk or a name
        of a simulation in the database.

    Parameters
    ----------
    arguments
            projectName: str
                The name of the project.
            workflowName: str
                A file on the disk or a simulation in the DB.
    Returns
    -------
        prints a list of all the nodes of the workflow.
    """
    logger = logging.getLogger("hera.bin.hera_workflows.listNodes")
    logger.info(f" -- Starting: Listing workflow nodes --")

    if os.path.exists(arguments.workflowName) and not os.path.isdir(arguments.workflowName):
            json = loadJSON(arguments.workflowName)
            hermesObject = workflow(json)
    else:
        if arguments.projectName is None:
            raise ValueError("Must supply a project name for a non-file workflow")

        wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=arguments.projectName)

        hermesObject = wftk.getHermesWorkflowFromDB(arguments.workflowName)

    tlte = f"The nodes of the {arguments.workflowName}"
    print(tlte)
    print("-"*len(tlte))

    if arguments.parameters:
        for hnodeName,hnodeData in hermesObject.items():
            print(f"\t * {hnodeName}")
            for prop in hnodeData.parameters.keys():
                print(f"\t\t + {prop}")
    else:
        print("\t * "+"\n\t * ".join(hermesObject.nodeList))

def workflowNodes_listParameters(arguments):
    """
            List the parameters of the node.

    Parameters
    ----------
    arguments
            projectName: str
                The name of the project.
            nodename : str
                The name of the node to list.

            workflowName: str
                A file on the disk or a simulation in the DB.

    Returns
    -------

    """
    logger = logging.getLogger("hera.bin.hera_workflows.listNodeParameters")
    logger.info(f" -- Starting: Listing node parameters --")

    if os.path.isfile(arguments.workflowName):
            json = loadJSON(arguments.workflowName)
            hermesObject = workflow(json)
    else:
        if arguments.projectName is None:
            raise ValueError("Must supply a project name for a non-file workflow")

        wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=arguments.projectName)

        hermesObject = wftk.getHermesWorkflowFromDB(arguments.workflowName)

    if arguments.nodeName not in hermesObject.nodeList:
        raise ValueError(f" Node {arguments.nodeName} not found in workflow {arguments.workflowName}. Existing nodes are: {','.join(hermesObject.nodeList)}")

    tlte = f"The parameters of the node {arguments.nodeName} in the workflow {arguments.workflowName}"
    print(tlte)
    print("-"*len(tlte))
    import json

    for nd,pm in hermesObject[arguments.nodeName].parameters.items():
        vls = json.dumps(pm,indent=4)
        print(f"-\t {nd}:  {vls}")

def workflow_compare(arguments):
    """
            Compares the parameters of the list of simulations that were supplied.
            Specifically for a list of simulations. Comparing all the simulations of a group is
            achieved with list simulations.

    Parameters
    ----------
    arguments
        projectName : str, the name of the projet

        simulations: [groupName] - compare all the simulations.old,
                     [sim1,sim2,..] compare the different simulations.old. simX is either a simulation name in the DB or a file on the disk


    Returns
    -------

    """
    logger = logging.getLogger("hera.bin.hera_workflows.workflow_compare")
    logger.info(f" -- Starting: Listing workflow nodes --")

    if arguments.projectName is None:
        logger.execution(f"projectName is not provided. Looking for the project name in the caseConfiguration.json file (projectName key) ")
        caseConfiguration = loadJSON("caseConfiguration.json")
        projectName = caseConfiguration['projectName']

    wftk = toolkitHome.getToolkit(toolkitName=toolkitHome.SIMULATIONS_WORKFLOWS, projectName=projectName)

    showAllParameters = arguments.all

    res = wftk.compareWorkflows(arguments.workflows,diffParams= not showAllParameters,longFormat=arguments.longFormat)

    if arguments.format == "pandas":
        output = res
    elif arguments.format == "latex":
        output = res.to_latex()
    else:

        output = json.dumps(loadJSON(res.to_json()),indent=4)

    print(output)


def workflow_expand(arguments):
    parser_expandWorkflow(arguments)

def workflow_build(arguments):
    handler_build(arguments)

def workflow_execute(arguments):
    handler_execute(arguments)

def workflow_buildExecute(arguments):
    handler_buildExecute(arguments)


if __name__ == "__main__":
    initialize_logging(
        with_logger("hera.simulations", handlers=['console'], level='DEBUG', propagate=False),
        with_logger("hera.simulations.hermesWorkflowToolkit", handlers=['console'], level='INFO', propagate=False),
        with_logger("hera.bin", handlers=['console'], level='DEBUG', propagate=False),
    )

    projectNameHelpDesc = 'The project name. [Optional]. If does not exist take from caseConfiguration'

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(help='Topic:')

    list_parser = subparsers.add_parser('list', help='Handles listing of the items')
    list_subparser = list_parser.add_subparsers(help='Handles simulation group')

    ##
    #   List group
    ##
    parser_prepare = list_subparser.add_parser('groups', help='List the group in the project.')
    parser_prepare.add_argument('--projectName', type=str, default=None, help=projectNameHelpDesc)
    parser_prepare.add_argument('--type', type=str,dest="type", default=None, help='Specify the simulation type')
    parser_prepare.add_argument('--simulationName',dest="simulationName",action="store_true", default=False, help='If exists, show the simulation names')
    parser_prepare.set_defaults(func=simulationGroup_list)


    ##
    #   List workflows in a group
    ##
    listSimulations_parser = list_subparser.add_parser('workflows', help='Lists the workflows in the group of that project.')
    listSimulations_parser.add_argument('object', type=str, default=None, help='A workflow file, a case directory, a name of simulation, or a group name. If None, print group and simulations in the project.')
    listSimulations_parser.add_argument('--projectName', dest="projectName", default=None, type=str, help=projectNameHelpDesc)
    #listSimulations_parser.add_argument('--parameters',nargs="*", dest="parametersOfNodes", default=None, help='List the paramaters. If  nodes are given, then only list theirs.')
    listSimulations_parser.add_argument('--nodes', dest="nodes",action="store_true", default=False, help='If exsists, list the nodes of each simulation')
    listSimulations_parser.add_argument('--parameters', dest="parameters", action="store_true", default=False,
                                        help='If exsists, list the nodes of each simulation with their parameters (replace --nodes)')
    #listSimulations_parser.add_argument('--JSON', dest="json", default=False, type=bool,
    #                                    help='If exsists, return the results as JSON and not as pandas table')
    listSimulations_parser.set_defaults(func=workflow_list)

    parser_prepare = subparsers.add_parser('add', help='Adds a workflow to the group.')
    parser_prepare.add_argument('workflow', type=str, help='The workflow file to load')
    parser_prepare.add_argument('--projectName', type=str, default=None, help=projectNameHelpDesc)
    parser_prepare.add_argument('--simulationGroup',dest="simulationGroup", default=None, type=str, help='The simulation group. [Optional]. If None, try to infer from the file name  ')
    parser_prepare.add_argument('--overwrite', dest="overwrite", action="store_true", default=False,
                                help='overwrite the existing workflow with the same name')
    parser_prepare.add_argument('--assignName', dest="assignName", action="store_true", default=False,
                                help='If true, finds a new name to the simulation based on the maximal id in the simulation group.')
    parser_prepare.add_argument('--force', dest="force", action="store_true", default=False,
                                help='Add the current workflow to the DB even if it exists there under a different name')
    parser_prepare.add_argument('--action', dest="action", choices=['Add', 'AddBuild', 'AddBuildExecute','add', 'addBuild', 'addBuildExecute'],
                                help='The action: just add, just add and build, or add,build and run',
                                default='AddBuildExecute')
    parser_prepare.set_defaults(func=workflow_add)


    ### ------------------------
    export = subparsers.add_parser('export', help='Saves the workflow to the disk.')
    # --build - also builds the python executer

    ### ------------------------
    compare_parser = subparsers.add_parser('compare', help='Compare two or more simulations.old. ')
    compare_parser.add_argument('workflows', nargs="+", type=str,
                                help='[groupName] - compare all the simulations.old, [sim1,sim2,..] compare the different simulations.old. simX is either a simulation name in the DB or a file on the disk')
    compare_parser.add_argument('--projectName', dest="projectName", default=None, type=str, help=projectNameHelpDesc)
    compare_parser.add_argument('--all', dest="all", action="store_true", default=False,
                                        help='If exsists, list all the parameters')
    compare_parser.add_argument('--longTable', dest="longFormat", action="store_true", default=False,
                                        help='If exsists, list the parameters as a long table. If does not exist data is pivoted')

    compare_parser.add_argument('--format', dest="format", default="pandas", choices=["pandas","json","latex"],
                                        help='The output format: pandas (print the pandas), json, latex')

    compare_parser.set_defaults(func=workflow_compare)

    ### ------------------------
    delete_parser = subparsers.add_parser('delete', help='Delete a workflow. Exports the simulation that was deleted ')
    delete_parser.add_argument('workflows', nargs="+", type=str,
                                help='[groupName] - compare all the simulations.old, [sim1,sim2,..] compare the different simulations.old. simX is either a simulation name in the DB or a file on the disk')
    delete_parser.add_argument('--projectName', type=str, default=None, help=projectNameHelpDesc)
    delete_parser.add_argument('--no-export',dest="noExport", default=False, action="store_true", help='Does not save the deleted workflow to the disk')
    delete_parser.add_argument('--forceOverwrite', dest="forceOverwrite", default=False, action="store_true",
                               help='Overwrite the export if the file exists')

    delete_parser.set_defaults(func=workflow_delete)
    # --includeRun - also deletes the run.
    # --group     - deletes all the simulation with that prefix.
    # --no-export  - does not save the deleted workflow to the disk.



    ##### execuion of the workflows.
    parser_expandWorkflow = subparsers.add_parser('expand',
                                                  help='Expands the workflow JSON with the default values of the nodes')
    parser_expandWorkflow.add_argument('workflow', type=str, help="base workflow")
    parser_expandWorkflow.add_argument('caseName', type=str, help="the name of the case to run")
    parser_expandWorkflow.set_defaults(func=workflow_expand)

    parser_buildExecuter = subparsers.add_parser('build',
                                                 help='Builds the python execution file for the execution engine ')
    parser_buildExecuter.add_argument('workflow', type=str, help="base workflow")
    parser_buildExecuter.add_argument('caseName', type=str, help="the name of the case to run")
    parser_buildExecuter.add_argument('--parameters', type=str, default=None, required=False,
                                      help="A path to paremeters file (optional)")
    parser_buildExecuter.set_defaults(func=workflow_build)

    parser_execute = subparsers.add_parser('execute',
                                           help='Runs the python execution file with the appropriate execution engine')
    parser_execute.add_argument('caseName', type=str, help="the name of the case to run")
    parser_execute.add_argument('--force', dest="force", default=False, action="store_true",
                                help="If exist, delete the execution files first")
    parser_execute.set_defaults(func=workflow_execute)

    parser_runWorkflow = subparsers.add_parser('buildExecute', help='Expands, builds and executes the workflow JSON')
    parser_runWorkflow.add_argument('workflow', type=str, help="base workflow")
    parser_runWorkflow.add_argument('--force', dest="force", default=False, action="store_true",
                                    help="If exist, delete the execution files first")
    parser_execute.set_defaults(func=workflow_buildExecute)


    parsed = parser.parse_args()

    parsed.func(parsed)
    # todo: add printint of the workflows.
